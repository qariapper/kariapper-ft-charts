<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Kariapper Family Tree – up to 3 generations</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<script src="https://d3js.org/d3.v7.min.js"></script>

<style>
 body{margin:0;font-family:"Segoe UI",sans-serif}
 h1{margin:12px 0;text-align:center}

 #controls{text-align:center;margin:10px}
 #tree_div{height:calc(100vh - 120px);width:100%;overflow:auto}

 svg{display:block;width:100%;height:auto}
 .trunk,.branch{fill:none;stroke:#888;stroke-width:1.5px;stroke-linecap:round}

 .node-rect{rx:4;ry:4;filter:drop-shadow(2px 2px 2px rgba(0,0,0,.14))}
 .gen1{fill:#eceff4;stroke:#4c566a}
 .gen2{fill:#e5e9f0;stroke:#3b4252}
 .gen3{fill:#d8dee9;stroke:#2e3440}
 .female{fill:#fbd3e0!important}
 .male  {fill:#d0e4f7!important}

 .node-text{pointer-events:none;text-anchor:start;dominant-baseline:central}
 .node{cursor:pointer}

 .tooltip{paint-order:stroke;font:13px sans-serif;fill:#333;
          stroke:#fff;stroke-width:.5;pointer-events:none}
</style>
</head>
<body>

<h1>Kariapper Family Tree – up to 3 generations</h1>

<div id="controls">
  <button onclick="toggleGen3()">Toggle Gen-3</button>
  <button onclick="zoomBy( 0.15)">+</button>
  <button onclick="zoomBy(-0.15)">−</button>
  <button onclick="resetZoom()">Reset</button>
</div>

<div id="tree_div">Loading…</div>

<script>
(async function(){

/* ───── CONFIG ───── */
const sheetID  = '1BE7PJAJs3QxHnOsb1z5cKnGHdjQCR8IksorMcAm7Fx8'; // Google-Sheet id
const charW    = 9;      // average character width (px)
const vSpacing = 40;     // vertical gap between siblings
const stub     = 20;     // ← the little horizontal stub
const indent   = 12;     // inset so branch lines don’t touch the box
const minBoxW  = 80;

/* ───── FETCH SHEET (JSON) ───── */
const raw = await fetch(
   `https://docs.google.com/spreadsheets/d/${sheetID}/gviz/tq?gid=0&headers=1&tqx=out:json`
 ).then(r=>r.text());
const json  = JSON.parse(raw.slice(raw.indexOf('(')+1,raw.lastIndexOf(')')));
const cols  = json.table.cols.map(c=>c.label);
const rows  = json.table.rows;

const idIdx     = cols.findIndex(h=>/\(dID\)$/i.test(h));
const nameIdx   = cols.findIndex(h=>h.trim()==='Full Name');
const genIdx    = cols.findIndex(h=>/^generation$/i.test(h));
const spouseIdx = cols.findIndex(h=>/^spouse/i.test(h));
const genderIdx = cols.findIndex(h=>/^gender$/i.test(h));

const flat = rows.map(r=>{
  const id     = r.c[idIdx]?.v ?? '';
  const name   = r.c[nameIdx]?.v ?? '';
  const gen    = +r.c[genIdx]?.v;
  const spouse = spouseIdx>-1 ? (r.c[spouseIdx]?.v ?? '') : '';
  const gRaw   = genderIdx>-1 ? (r.c[genderIdx]?.v ?? '').toLowerCase() : '';
  const gender = gRaw.startsWith('f')?'f':gRaw.startsWith('m')?'m':'';
  return {id,name,gen,spouse,gender,
          parent:id.includes('.')?id.replace(/\.[^.]+$/,''):'',children:[]};
}).filter(d=>d.id && d.name && Number.isFinite(d.gen) && d.gen<=3);

const byId = Object.fromEntries(flat.map(d=>[d.id,d]));
flat.forEach(d=>{ if(d.parent&&byId[d.parent]) byId[d.parent].children.push(d); });
const rootData = byId['ALK'];
if(!rootData){ document.getElementById('tree_div').textContent='❌ root “ALK” not found'; return;}

const root = d3.hierarchy(rootData,d=>d.children);
const tree = d3.tree().nodeSize([vSpacing,180]);

// collapse gen-3 initially
root.descendants().forEach(d=>{
  if(d.data.gen===2 && d.children){ d._children=d.children; d.children=null; }
});

const svg   = d3.select('#tree_div').html('').append('svg').attr('preserveAspectRatio','xMinYMin meet');
const gZoom = svg.append('g');
const g     = gZoom.append('g');

const zoom  = d3.zoom().scaleExtent([.5,2]).on('zoom',({transform})=>gZoom.attr('transform',transform));
svg.call(zoom);

const tooltip = g.append('text').attr('class','tooltip').style('display','none');

/* ───── HELPERS ───── */
function labelText(d){
  const sign = d.data.gender==='f'?' ♀':d.data.gender==='m'?' ♂':'';
  return `${d.data.name}${sign} ${d.data.id}`;
}
const nodeWidth = d=>Math.max(minBoxW, labelText(d).length*charW + 20);
const rightEdgeX = d => d.y + nodeWidth(d)/2 + indent;

/* ───── DRAW ───── */
function update(){

  const hSpacing = Math.max(180,d3.max(root.descendants(),nodeWidth)+60);
  tree.nodeSize([vSpacing,hSpacing])(root);

  const alignedX = d3.max(root.descendants().filter(d=>d.data.gen===2), rightEdgeX) + stub;

  /* trunks */
  g.selectAll('path.trunk')
   .data(root.descendants().filter(d=>d.children?.length),d=>d.data.id)
   .join(enter=>enter.append('path').attr('class','trunk'))
   .attr('d',d=>{
       const px = rightEdgeX(d);
       const tx = d.depth===1 ? alignedX : px+stub;
       const ys = d.children.map(c=>c.x);
       return `M${px},${d.x}H${tx}M${tx},${d3.min(ys)}V${d3.max(ys)}`;
   });

  /* branches */
  g.selectAll('path.branch')
   .data(root.links(),d=>d.target.data.id)
   .join(enter=>enter.append('path').attr('class','branch'))
   .attr('d',d=>{
       const pX   = d.source.depth===1 ? alignedX : rightEdgeX(d.source);
       const cX   = d.target.depth===2 ? alignedX : rightEdgeX(d.target);
       const hitX = d.target.children ? cX : cX + stub;
       return `M${pX},${d.target.x}H${hitX}`;
   });

  /* nodes */
  const nodeSel = g.selectAll('g.node')
      .data(root.descendants(),d=>d.data.id)
      .join(enter=>{const n=enter.append('g').attr('class','node').on('click',toggle);
                    n.append('rect'); n.append('text'); return n;});

  nodeSel.each(function(d){
      const n = d3.select(this);
      const w = nodeWidth(d);

      /* NEW position logic ----------------------------------------- */
      let base;
      if (!d.parent) {                   // root
          base = d.y - w/2;
      } else if (d.parent.depth === 1) { // gen-2 leaves
          base = alignedX + stub;
      } else {                           // every other node
          base = rightEdgeX(d.parent) + indent;
      }

      n.attr('transform',`translate(${base},${d.x})`);

      const genderCls = d.data.gender==='f'?'female':d.data.gender==='m'?'male':'';
      n.select('rect')
        .attr('class',`node-rect gen${d.data.gen} ${genderCls}`)
        .attr('x',0).attr('y',-12).attr('width',w).attr('height',24);
      n.select('text')
        .attr('class','node-text').attr('x',10).attr('y',0)
        .text(labelText(d));

      n.on('mouseover',()=>{
          tooltip.text(d.data.spouse?'Spouse(s): '+d.data.spouse:'Spouse(s): –')
                 .attr('x',base+6).attr('y',d.x-18)
                 .style('display','block');
      }).on('mouseout',()=>tooltip.style('display','none'));
  });

  /* view-box */
  const nodes=root.descendants();
  const left  = d3.min(nodes,d=>{
        if(!d.parent) return d.y - nodeWidth(d)/2;
        if(d.parent.depth===1) return alignedX + stub;
        return rightEdgeX(d.parent) + indent;
  });
  const right = d3.max(nodes,d=>{
        if(!d.parent) return d.y + nodeWidth(d)/2;
        if(d.parent.depth===1) return alignedX + stub + nodeWidth(d);
        return rightEdgeX(d.parent) + indent + nodeWidth(d);
  });
  const top    = d3.min(nodes,d=>d.x-14);
  const bottom = d3.max(nodes,d=>d.x+14);
  const M=60;
  svg.attr('viewBox',`${left-M} ${top-M} ${(right-left)+2*M} ${(bottom-top)+2*M}`);
}

/* collapse / expand */
let collapsed=true;
function toggleGen3(){
  root.descendants().forEach(d=>{
      if(d.data.gen===2){
        if(collapsed && d._children){d.children=d._children;d._children=null;}
        else if(!collapsed && d.children){d._children=d.children;d.children=null;}
      }
  });
  collapsed=!collapsed;
  update();
}
function toggle(e,d){ if(d.children){d._children=d.children;d.children=null;}
                      else if(d._children){d.children=d._children;d._children=null;}
                      update(); }

/* zoom helpers */
window.zoomBy    = dz => svg.transition().duration(200).call(zoom.scaleBy,1+dz);
window.resetZoom = () => svg.transition().duration(200).call(zoom.transform,d3.zoomIdentity);
window.toggleGen3 = toggleGen3;                 /* ← button can now see it */

/* first paint */
update();
})();
</script>
</body>
</html>
