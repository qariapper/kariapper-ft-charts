<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Kariapper Family Tree – up to 3 generations</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { margin:0; font-family: "Segoe UI", sans-serif; }
    h1   { text-align:center; margin:12px 0; }
    #tree_div { width:100%; height:calc(100vh - 50px); overflow:auto; }
    svg  { display:block; width:100%; height:auto; }

    .trunk,.branch { fill:none; stroke:#888; stroke-width:1.5px; stroke-linecap:round; }
    .node-rect { rx:4; ry:4; filter:drop-shadow(2px 2px 2px rgba(0,0,0,.15)); }
    .gen1{fill:#eceff4;stroke:#4c566a} .gen2{fill:#e5e9f0;stroke:#3b4252} .gen3{fill:#d8dee9;stroke:#2e3440}
    .node-text { pointer-events:none; text-anchor:start; dominant-baseline:central; }
    .node { cursor:pointer; }
  </style>
</head>
<body>
  <h1>Kariapper Family Tree – up to 3 generations - 30</h1>
  <div id="tree_div">Loading…</div>

<script>
(async function () {

  /* 1 ── load Google Sheet ------------------------------------------------ */
  const sheetID = '1BE7PJAJs3QxHnOsb1z5cKnGHdjQCR8IksorMcAm7Fx8';
  const raw = await fetch(
      `https://docs.google.com/spreadsheets/d/${sheetID}/gviz/tq?gid=0&headers=1&tqx=out:json`
    ).then(r => r.text());
  const json = JSON.parse(raw.slice(raw.indexOf('(')+1, raw.lastIndexOf(')')));
  const headers = json.table.cols.map(c=>c.label);
  const rows    = json.table.rows;

  /* 2 ── column indexes --------------------------------------------------- */
  const idIdx     = headers.findIndex(h=>/\(dID\)$/.test(h));
  const nameIdx   = headers.findIndex(h=>h.trim()==='Full Name');
  const genIdx    = headers.findIndex(h=>/^generation$/i.test(h));
  const spouseIdx = headers.findIndex(h=>/spouse/i.test(h));
  if([idIdx,nameIdx,genIdx,spouseIdx].some(i=>i<0)){
    document.getElementById('tree_div').innerText = '❌ Sheet is missing one of the required columns.';
    return;
  }

  /* 3 ── flatten rows ----------------------------------------------------- */
  const flat = rows.map(r=>{
      const id = r.c[idIdx]?.v || '';
      return {
        id,
        name  : r.c[nameIdx]?.v || '',
        gen   : +r.c[genIdx]?.v,
        parent: id.includes('.') ? id.replace(/\.[^.]+$/, '') : '',
        spouse: r.c[spouseIdx]?.v || '',
        children:[]
      };
    }).filter(d=>d.id && d.name && Number.isFinite(d.gen) && d.gen<=3);

  /* 4 ── build hierarchy -------------------------------------------------- */
  const byId = Object.fromEntries(flat.map(d=>[d.id,d]));
  flat.forEach(d => { if(d.parent && byId[d.parent]) byId[d.parent].children.push(d); });

  const rootData = byId['ALK'];
  if(!rootData){
    document.getElementById('tree_div').innerText = '❌ Root “ALK” not found – check dID values.';
    return;
  }

  /* 5 ── layout helpers --------------------------------------------------- */
  const charWidth = 9;                                   // average text-char width
  const maxName   = d3.max(flat, d=>d.name.length);
  const hSpacing  = Math.max(180, maxName*charWidth + 50);   // col-to-col distance
  const vSpacing  = 40;                                   // row spacing
  const stub      = 20;                                   // short back-stub length
  const indent    = 12;                                   // box offset from trunk

  const root = d3.hierarchy(rootData, d=>d.children);
  const tree = d3.tree().nodeSize([vSpacing, hSpacing]);

  /* collapse Gen-2 initially */
  root.descendants().forEach(d=>{
    if(d.data.gen===2 && d.children){ d._children=d.children; d.children=null; }
  });

  /* 6 ── SVG scaffolding -------------------------------------------------- */
  const svg = d3.select('#tree_div').html('').append('svg')
                .attr('preserveAspectRatio','xMinYMin meet');
  const zoomGroup  = svg.append('g');
  const chartGroup = zoomGroup.append('g');
  svg.call(d3.zoom()
          .scaleExtent([0.5,2])
          .on('zoom', ({transform}) => zoomGroup.attr('transform', transform)));

  function toggle(_, d){
    if(d.data.gen===2){
      d.children ? (d._children=d.children, d.children=null)
                 : (d.children=d._children, d._children=null);
      update();
    }
  }

  /* ------------- UPDATE -------------------------------------------------- */
  function update () {
    tree(root);                         /* <<< run layout first */

    /* helper: absolute column X for a given depth */
    const colX = depth => depth * hSpacing;

    /* responsive viewBox / pan frame */
    const xs = root.descendants().map(d=>d.x);
    const ys = root.descendants().map(d=>colX(d.depth));
    const M  = 100;
    svg.attr('viewBox',
      [0,0,
       Math.max(...ys)-Math.min(...ys)+M*2,
       Math.max(...xs)-Math.min(...xs)+M*2].join(' '));
    chartGroup.attr('transform',
      `translate(${M-Math.min(...ys)},${M-Math.min(...xs)})`);

    /* 1 ── vertical trunks + back-stubs */
    chartGroup.selectAll('path.trunk')
      .data(root.descendants().filter(d=>d.children?.length), d=>d.data.id)
      .join(
        enter=>enter.append('path').attr('class','trunk'),
        update=>update,
        exit=>exit.remove()
      )
      .attr('d', d=>{
        const xCol = colX(d.depth);
        const ys   = d.children.map(c=>c.x);
        const vert = `M${xCol},${d3.min(ys)}V${d3.max(ys)}`;
        const horiz= d.depth
                   ? `M${xCol-stub},${d.x}H${xCol}`    // back-stub for depth≥1
                   : `M${xCol},${d.x}H${xCol+stub}`;   // tiny forward stub for root
        return (horiz+vert).replace(/\s+/g,'');
      });

    /* 2 ── horizontal branches (parent-trunk → child-trunk) */
    chartGroup.selectAll('path.branch')
      .data(root.links(), d=>d.target.data.id)
      .join(
        enter=>enter.append('path').attr('class','branch'),
        update=>update,
        exit=>exit.remove()
      )
      .attr('d', d=>`M${colX(d.source.depth)},${d.target.x}H${colX(d.target.depth)}`);

    /* 3 ── node groups ---------------------------------------------------- */
    chartGroup.selectAll('g.node')
      .data(root.descendants(), d=>d.data.id)
      .join(
        enter=>{
          const g=enter.append('g').attr('class','node').on('click',toggle);
          g.append('rect'); g.append('text'); g.append('title');
          return g;
        },
        update=>update,
        exit=>exit.remove()
      )
      .each(function(d){
        const g  = d3.select(this);
        const txt= d.data.name;
        const w  = Math.max(80, txt.length*charWidth + 20);
        const x  = d.depth ? colX(d.depth)+indent : colX(0);   // indent only depth>0

        g.attr('transform', `translate(${x},${d.x})`);
        g.select('rect')
          .attr('class',`node-rect gen${d.data.gen}`)
          .attr('x',0).attr('y',-12)
          .attr('width',w).attr('height',24);
        g.select('text')
          .attr('class','node-text')
          .attr('x',10).attr('y',0)
          .text(txt);
        g.select('title').text(
          d.data.spouse ? `Spouse(s): ${d.data.spouse}` : txt
        );
      });
  }

  update();                              // first draw
})();
</script>
</body>
</html>
