<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Kariapper Family Tree – up to 3 generations</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body{margin:0;font-family:"Segoe UI",sans-serif}
    h1{text-align:center;margin:12px 0}
    #tree_div{width:100%;height:calc(100vh - 50px);overflow:auto}
    svg{display:block;width:100%;height:auto}
    .trunk,.branch{fill:none;stroke:#888;stroke-width:1.5px;stroke-linecap:round}
    .node-rect{rx:4;ry:4;filter:drop-shadow(2px 2px 2px rgba(0,0,0,.15))}
    .gen1{fill:#eceff4;stroke:#4c566a}
    .gen2{fill:#e5e9f0;stroke:#3b4252}
    .gen3{fill:#d8dee9;stroke:#2e3440}
    .node-text{pointer-events:none;text-anchor:start;dominant-baseline:central}
    .node{cursor:pointer}
  </style>
</head>
<body>
  <h1>Kariapper Family Tree – up to 3 generations – ver 25</h1>
  <div id="tree_div">Loading…</div>

<script>
(async function () {
  /* ------------  data load  ------------ */
  const sheetID='1BE7PJAJs3QxHnOsb1z5cKnGHdjQCR8IksorMcAm7Fx8';
  const raw=await fetch(`https://docs.google.com/spreadsheets/d/${sheetID}/gviz/tq?gid=0&headers=1&tqx=out:json`)
                 .then(r=>r.text());
  const json = JSON.parse(raw.slice(raw.indexOf('(')+1,raw.lastIndexOf(')')));
  const headers = json.table.cols.map(c=>c.label), rows=json.table.rows;

  const idIdx=headers.findIndex(h=>/\(dID\)$/.test(h));
  const nameIdx=headers.findIndex(h=>h.trim()==='Full Name');
  const genIdx=headers.findIndex(h=>/^generation$/i.test(h));
  const spouseIdx=headers.findIndex(h=>/spouse/i.test(h));
  if([idIdx,nameIdx,genIdx,spouseIdx].some(i=>i<0)){document.getElementById('tree_div').innerText='❌ missing columns';return;}

  const flat=rows.map(r=>{
      const id=r.c[idIdx]?.v||'';
      return{id,
        name:r.c[nameIdx]?.v||'',
        gen:+r.c[genIdx]?.v,
        parent:id.includes('.')?id.replace(/\.[^.]+$/,''):'',
        spouse:r.c[spouseIdx]?.v||'',
        children:[]};
    }).filter(d=>d.id&&d.name&&Number.isFinite(d.gen)&&d.gen<=3);

  const byId=Object.fromEntries(flat.map(d=>[d.id,d]));
  flat.forEach(d=>{if(d.parent&&byId[d.parent])byId[d.parent].children.push(d);});
  const rootData=byId['ALK']; if(!rootData){document.getElementById('tree_div').innerText='❌ root ALK not found';return;}

  /* ------------  layout helpers ------------ */
  const charWidth=9;
  const hSpacing=220,                    /* horizontal gap between generations   */
        vSpacing=40;                    /* vertical row gap                     */
  const stub   = 20,                    /* length of left-running stub          */
        indent = 12;                    /* box indent after its own trunk       */

  const root=d3.hierarchy(rootData,d=>d.children);
  const tree=d3.tree().nodeSize([vSpacing,hSpacing]);

  root.descendants().forEach(d=>{ if(d.data.gen===2&&d.children){d._children=d.children;d.children=null;} });

  const svg=d3.select('#tree_div').html('').append('svg').attr('preserveAspectRatio','xMinYMin meet');
  const zoomGroup=svg.append('g'), chartGroup=zoomGroup.append('g');
  svg.call(d3.zoom().scaleExtent([0.5,2]).on('zoom',({transform})=>zoomGroup.attr('transform',transform)));

  function toggle(_,d){
      if(d.data.gen===2){
        d.children ? (d._children=d.children, d.children=null)
                   : (d.children=d._children, d._children=null);
        update();
      }
  }

  /* ------------  UPDATE   ------------ */
/* ------------------------------------------------------------------ */
/*  UPDATE — recompute layout & redraw                                */
/* ------------------------------------------------------------------ */
function update () {
  tree(root);                                   // 1 layout (x / y)

  /* 2 ── compute max label-width per generation & column X positions */
  const stub   = 20,          // stub length (trunk → start of box)
        indent = 0,           // extra indent after the stub
        gap    = 40,          // gap between one gen’s box and next gen’s trunk
        charW  = charWidth;   // from outer scope

  // max visible box-width by depth
  const depths = [];
  root.descendants().forEach(d => {
    const w = Math.max(80, d.data.name.length * charW + 20);
    depths[d.depth] = Math.max(depths[d.depth] || 0, w);
  });

  // column X coordinate for each generation
  const colX = [0];                                // depth 0 trunk at 0
  for (let i = 1; i < depths.length; i++) {
    colX[i] = colX[i-1] + depths[i-1] + stub + gap;
  }

  /* 3 ── responsive viewBox */
  const xs = root.descendants().map(d => d.x);
  // rightmost edge = columnX + stub + indent + its own width
  const rightEdge = d3.max(root.descendants(), d =>
    colX[d.depth] + stub + indent +
    Math.max(80, d.data.name.length * charW + 20));

  const M = 100;   // margin
  svg.attr('viewBox',
           [0, 0,
            rightEdge + M,
            d3.max(xs) - d3.min(xs) + M * 2].join(' '));
  chartGroup.attr('transform',
    `translate(${M},${M - d3.min(xs)})`);

  /* 4 ── tiny stub for EVERY node (so parent boxes don’t sit flush) */
  chartGroup.selectAll('path.stub')
    .data(root.descendants(), d => d.data.id)
    .join(
      enter => enter.append('path').attr('class','branch stub'),
      update => update,
      exit   => exit.remove()
    )
    .attr('d', d => {
      const x0 = colX[d.depth];
      return `M${x0},${d.x}H${x0 + stub}`;
    });

  /* 5 ── vertical trunks (only nodes with visible children) */
  chartGroup.selectAll('path.trunk')
    .data(root.descendants().filter(d => d.children && d.children.length),
          d => d.data.id)
    .join(
      enter => enter.append('path').attr('class','trunk'),
      update => update,
      exit   => exit.remove()
    )
    .attr('d', d => {
      const x = colX[d.depth];
      const ys = d.children.map(c => c.x);
      return `M${x},${d3.min(ys)}V${d3.max(ys)}`;
    });

  /* 6 ── horizontal branches (parent-stub → child trunk) */
  chartGroup.selectAll('path.branch.core')
    .data(root.links(), d => d.target.data.id)
    .join(
      enter => enter.append('path').attr('class','branch core'),
      update => update,
      exit   => exit.remove()
    )
    .attr('d', d => {
      const x1 = colX[d.source.depth] + stub;   // end of parent stub
      const x2 = colX[d.target.depth];          // child trunk
      return `M${x1},${d.target.x}H${x2}`;
    });

  /* 7 ── node boxes + labels */
  chartGroup.selectAll('g.node')
    .data(root.descendants(), d => d.data.id)
    .join(
      enter => {
        const g = enter.append('g').attr('class','node').on('click', toggle);
        g.append('rect'); g.append('text'); g.append('title');
        return g;
      },
      update => update,
      exit   => exit.remove()
    )
    .each(function (d) {
      const g   = d3.select(this),
            txt = d.data.name,
            boxW = Math.max(80, txt.length * charW + 20);

      const left = colX[d.depth] + stub + indent;   // left edge of box
      g.attr('transform', `translate(${left},${d.x})`);

      g.select('rect')
       .attr('class',`node-rect gen${d.data.gen}`)
       .attr('x',0).attr('y',-12)
       .attr('width',boxW).attr('height',24);

      g.select('text')
       .attr('class','node-text')
       .attr('x',10).attr('y',0)
       .text(txt);

      g.select('title')
       .text(d.data.spouse ? `Spouse(s): ${d.data.spouse}` : txt);
    });
}








  update();
})();
</script>
</body>
</html>
