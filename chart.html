<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Kariapper Family Tree – up to 3 generations</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { margin:0; font-family:"Segoe UI",sans-serif }
    h1  { text-align:center; margin:12px 0 }
    #tree_div { width:100%; height:calc(100vh - 50px); overflow:auto }
    svg { display:block; width:100%; height:auto }

    .trunk,
    .branch {
      fill:none;
      stroke:#888;
      stroke-width:1.5px;
      stroke-linecap:round;
    }

    .node-rect {
      rx:4; ry:4;
      filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.15));
    }
    .gen1 { fill:#eceff4; stroke:#4c566a }
    .gen2 { fill:#e5e9f0; stroke:#3b4252 }
    .gen3 { fill:#d8dee9; stroke:#2e3440 }

    .node-text {
      pointer-events:none;
      text-anchor:start;        /* left-aligned */
      dominant-baseline:central;
    }
    .node { cursor:pointer }
  </style>
</head>
<body>
  <h1>Kariapper Family Tree – up to 3 generations - ver7</h1>
  <div id="tree_div">Loading…</div>


<script>
(async function(){
  // 1) Fetch & parse your Master tab
  const sheetID = '1BE7PJAJs3QxHnOsb1z5cKnGHdjQCR8IksorMcAm7Fx8';
  const raw = await fetch(
    `https://docs.google.com/spreadsheets/d/${sheetID}/gviz/tq`
    + `?sheet=Master`
    + `&headers=1`
    + `&tqx=out:json`
  ).then(r=>r.text());
  const json = JSON.parse(raw.slice(raw.indexOf('(')+1, raw.lastIndexOf(')')));
  console.log('Loaded rows:', json.table.rows.length);

  const headers = json.table.cols.map(c=>c.label);
  const rows    = json.table.rows;

  // 2) Column indexes
  const idIdx     = headers.findIndex(h=>/\(dID\)$/.test(h));
  const nameIdx   = headers.findIndex(h=>h.trim()==='Full Name');
  const genIdx    = headers.findIndex(h=>/gen\s*level/i.test(h));
  const spouseIdx = headers.findIndex(h=>/spouse/i.test(h));
  if ([idIdx,nameIdx,genIdx,spouseIdx].some(i=>i<0)) {
    document.getElementById('tree_div').innerText =
      '❌ Missing one of: dID, Full Name, Gen Level or Spouse(s) columns.';
    return;
  }

  // 3) Flatten & filter generations 1–3
  const flat = rows.map(r=>{
    return {
      id:     r.c[idIdx]?.v||'',
      name:   r.c[nameIdx]?.v||'',
      gen:    +r.c[genIdx]?.v,
      parent: (r.c[idIdx]?.v||'').replace(/\.[^.]+$/,''),
      spouse: r.c[spouseIdx]?.v||'',
      children: []
    };
  }).filter(d=>d.id && d.name && d.gen>=1 && d.gen<=3);

  // 4) Nest by ID
  const byId = {};
  flat.forEach(d=>byId[d.id]=d);
  flat.forEach(d=>{
    if (d.parent && byId[d.parent]) byId[d.parent].children.push(d);
  });

  const rootData = byId['ALK'];
  if (!rootData) {
    document.getElementById('tree_div').innerText =
      '❌ Root “ALK” not found – check your dID values.';
    return;
  }

  // 5) Spacing metrics
  const charWidth  = 7;                            // <— define this!
  const maxNameLen = d3.max(flat, d=>d.name.length);
  const hSpacing   = Math.max(180, maxNameLen*charWidth + 50);
  const vSpacing   = 40;

  // 6) Build the D3 hierarchy (no initial tree(root) call here)
  const root = d3.hierarchy(rootData, d=>d.children);
  const tree = d3.tree().nodeSize([vSpacing, hSpacing]);

  // 7) Collapse all generation-2 by default
  root.descendants().forEach(d=>{
    if (d.data.gen===2 && d.children) {
      d._children = d.children;
      d.children  = null;
    }
  });

  // 8) Compute full SVG extents
  const all = root.descendants();
  const xs  = all.map(d=>d.x), ys = all.map(d=>d.y);
  const minX = Math.min(...xs), maxX = Math.max(...xs);
  const minY = Math.min(...ys), maxY = Math.max(...ys);
  const margin = 100;
  const W = maxY - minY + margin*2;
  const H = maxX - minX + margin*2;

  // 9) Create responsive SVG
  const svg = d3.select('#tree_div').html('')
    .append('svg')
    .attr('viewBox',[0,0,W,H].join(' '))
    .attr('preserveAspectRatio','xMinYMin meet');

  const zoomGroup  = svg.append('g');
  const chartGroup = zoomGroup.append('g')
    .attr('transform',`translate(${margin-minY},${margin-minX})`);

  svg.call(d3.zoom()
    .scaleExtent([0.5,2])
    .on('zoom',({transform})=> zoomGroup.attr('transform',transform))
  );

  // 10) Click-to-toggle gen 2
  function toggle(_,d){
    if (d.data.gen===2){
      if (d.children)    d._children=d.children, d.children=null;
      else               d.children=d._children, d._children=null;
      update();
    }
  }

  // 11) Single draw/update
  function update(){
    tree(root);    // <— only call tree() now that hSpacing is known

    const stub = 20;

    // a) Vertical trunks + stub
    const parents = root.descendants().filter(d=>d.children && d.children.length>0);
    const trunks = chartGroup.selectAll('path.trunk')
      .data(parents, d=>d.data.id);

    trunks.join(
      enter => enter.append('path').attr('class','trunk'),
      upd   => upd,
      exit  => exit.remove()
    )
    .attr('d', d=>{
      const pw = Math.max(80, d.data.name.length*charWidth + 20);
      const px = d.y + pw/2;
      const tx = px + stub;
      const ys = d.children.map(c=>c.x);
      const y0 = Math.min(...ys), y1 = Math.max(...ys);
      return `M${px},${d.x}H${tx}M${tx},${y0}V${y1}`;
    });

    // b) Horizontal branches
    const branches = chartGroup.selectAll('path.branch')
      .data(root.links(), d=>d.target.data.id);

    branches.join(
      enter => enter.append('path').attr('class','branch'),
      upd   => upd,
      exit  => exit.remove()
    )
    .attr('d', d=>{
      const pw     = Math.max(80, d.source.data.name.length*charWidth + 20);
      const startX = d.source.y + pw/2 + stub;
      const tw     = Math.max(80, d.target.data.name.length*charWidth + 20);
      const endX   = d.target.y - tw/2;
      return `M${startX},${d.target.x}H${endX}`;
    });

    // c) Nodes (left-aligned)
    const nodes = chartGroup.selectAll('g.node')
      .data(root.descendants(), d=>d.data.id);

    const nodesEnter = nodes.join(
      enter=>{
        const g = enter.append('g').attr('class','node').on('click',toggle);
        g.append('rect'); g.append('text'); g.append('title');
        return g;
      },
      upd=>upd,
      exit=>exit.remove()
    );

    nodesEnter.merge(nodes).each(function(d){
      const g   = d3.select(this),
            txt = d.data.name,
            tw  = Math.max(80, txt.length*charWidth + 20);

      // align left edge
      g.attr('transform',`translate(${d.y - tw/2},${d.x})`);

      g.select('rect')
       .attr('class',`node-rect gen${d.data.gen}`)
       .attr('x',0).attr('y',-12)
       .attr('width',tw).attr('height',24);

      g.select('text')
       .attr('class','node-text')
       .attr('x',10).attr('y',0)
       .text(txt);

      g.select('title')
       .text(d.data.spouse ? `Spouse(s): ${d.data.spouse}` : txt);
    });
  }

  // 12) First draw
  update();

})();  // end async
</script>


</body>
</html>
